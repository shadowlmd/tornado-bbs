type
  FreeListArray = array[257..8192] of {$IFDEF VirtualPascal} SmallWord {$ELSE} Word {$ENDIF};
  FreeListPtr = ^FreeListArray;

const
  LocalHeaderSig    : Longint = $04034B50;  {signatures}
  CentralDirHeadSig : Longint = $02014B50;
  CentralDirTailSig : Longint = $06054B50;

  MaxUnzipVer       = 20;                                              {!!.01}

  MinCodeBits = 9;      {Starting code size}
  MaxCodeBits = 13;     {Maximum code size}
  TableSize   = 8191;   {Table holds 4K entries}
  Special     = 256;    {Special function code}
  CodeIncSize = 1;      {Indicates jump in code size}
  ClearCode   = 2;      {Indicates code table cleared}
  FirstFree   = 257;    {First available table entry}
  Unused      = -1;     {Prefix code for unused table entry}

var
  SaveName    : PathStr;          {Name of current ZIP file}
  NewZip      : File;             {File var for updating the ZIP}
  CDT         : CentralDirTail;   {Global central dir tail}
  CDTComment  : CommentPtr;       {Global ZIP file comment}
  NextFree    : Word;             {FreeList index}
  ClearList   : array[0..1023] of Byte;  {Used for adaptive resets}
  FreeList    : FreeListPtr;      {Used after adaptive resets}
  CodeSize    : Byte;             {Bit size of current codes}
  MaxCode     : Word;             {Largest code in CodeSize bits}
  BitBuffer   : LongInt;          {32bit buffer for handling bit output}
  BitsUsed    : Byte;             {Number of bits currently in bit buffer}
  CompressSize: LongInt;          {Size of compressed file}
  Prefix      : Word;             {Current prefix character}
  InFile      : File;             {File being compressed}
  FileIsText  : Boolean;          {True if current file is text}
  PendingClear: Boolean;          {True when string table needs to be cleared}
  NewFilePending : Boolean;       {True if new file just created}
  Freshening  : Boolean;          {True when Freshening an archive}
  BytesOut    : LongInt;          {Bytes written so far}
  OrigFileSize: LongInt;          {Original size of current file}
  ShowProg    : Boolean;          {Convenient boolean for show prog testing}
  ZipF        : File;             {Input zip file}
  TailPos     : LongInt;

  CompressMode: CompressionMode;  {Mode requested}
  CompressionUsed : Integer;      {Mode ac«tualy used}
  OptionFlags : Integer;          {General pourpose bit flags}         {!!.01}

  {Variables use to adjust implode compression vs speed}
  MaxStringMatch : Integer;
  MaxChainLength : Integer;

  DeflateLevel   : Byte;                                               {!!.01}

var
  {user hooks}
  glOKF : OkToWriteFunc;
  glSCP : ShowCommentsProc;
  glSMP : ShowMethodProc;
  glESF : ExtractSuccessFunc;
  glSPF : ShowProgressFunc;
  glOKC : OktoCompressFunc;
  glCSF : CompressSuccessFunc;
  glFCF : FileCommentFunc;

  function SkipZipData(N : LongInt) : Word;
    {-Skip the next N bytes of data in ZipF}
  {$IFDEF VIRTUALPASCAL}
  Var
    rc : ApiRet;
    Pos : Longint;
  begin
    If N > 0 then
      With FileRec( ZipF ) do
        begin
          rc := DosSetFilePtr( Handle, N, file_Current, Pos );

          SkipZipData := rc;
        end;
  {$ELSE}
  var
    Regs : Registers;
    Handle : Word absolute ZipF;
  begin
    SkipZipData := 0;
    if N > 0 then
      with Regs do begin
        AX := $4201;         {move file pointer function, relative to current pos}
        BX := Handle;        {file handle}
        CX := LH(N).H;       {CX has high word of delta}
        DX := LH(N).L;       {DX has low word}
        MsDos(Regs);
        if Odd(Flags) then
          SkipZipData := AX;
      end;
  {$ENDIF}
  end;

  function SkipNewZip(N : LongInt) : Word;
    {-Skip the next N bytes of data in NewZip}
  {$IFDEF VIRTUALPASCAL}
  Var
    rc : ApiRet;
    Pos : Longint;
  begin
    SkipNewZip := 0;
    If N > 0 then
      With FileRec( NewZip ) do
        begin
          rc := DosSetFilePtr( Handle, N, file_Current, Pos );

          SkipNewZip := rc;
        end;
  {$ELSE}
  var
    Regs : Registers;
    Handle : Word absolute NewZip;
  begin
    SkipNewZip := 0;
    if N > 0 then
      with Regs do begin
        AX := $4201;         {move file pointer function, relative to current pos}
        BX := Handle;        {file handle}
        CX := LH(N).H;       {CX has high word of delta}
        DX := LH(N).L;       {DX has low word}
        MsDos(Regs);
        if Odd(Flags) then
          SkipNewZip := AX;
      end;
  {$ENDIF}
  end;

  function ReadSignature(var Sig : LongInt) : Word;
    {-Read a signature from the ZIP file and return IoResult}
  begin
    BlockRead(ZipF, Sig, SizeOf(Sig));
    ReadSignature := IoResult;
  end;

  function ReadString(L : Word; var S : String; Max : Byte) : Word;
    {-Read a string of length L from the ZIP file}
  var
    SLen : Byte absolute S;
    I : Word;
  begin
    ReadString := 0;                                                   {!!.02}
    {read at most Max bytes into S}
    if L < Max then
      SLen := L
    else
      SLen := Max;
    BlockRead(ZipF, S[1], SLen);
    I := IoResult;

    {if we truncated the string, skip over the bytes we didn't read}
    if (I = 0) then
      ReadString := SkipZipData(SLen-L)                                {!!.02}
    else                                                               {!!.02}
      ReadString := I;                                                 {!!.02}
  end;

  function ReadLocalHeader(var LH : LocalHeader; var FName : PathStr) : Word;
    {-Read a local header from the ZIP file and return IoResult}
  var
    I : Word;
  begin
    BlockRead(ZipF, LH, SizeOf(LH));
    I := IoResult;
    if I = 0 then
      I := ReadString(LH.NameLength, FName, SizeOf(PathStr)-1);
    if (I = 0) then
      I := SkipZipData(LH.ExtraLength);
    ReadLocalHeader := I;
  end;

  function ReadOneComment(var CP : CommentPtr; Len : Word) : Word;
    {-Allocate a CommentPtr and read a Comment into it}
  var
    I : Word;
  begin
    if not GetMemCheck(CP, Len) then
      ReadOneComment := ecOutOfMemory
    else begin
      BlockRead(ZipF, CP^, Len);
      I := IoResult;
      if I <> 0 then begin
        FreeMem(CP, Len);
        CP := nil;
      end;
      ReadOneComment := I;
    end;
  end;

  function ReadOneExtraField(var EP : ExtraPtr; Len : Word) : Word;
    {-Allocate an ExtraPtr and read an ExtraField into it}
  var
    I : Word;
  begin
    if Len = 0 then
      ReadOneExtraField := 0
    else begin
      if not GetMemCheck(EP, Len) then
        ReadOneExtraField := ecOutOfMemory
      else begin
        BlockRead(ZipF, EP^, Len);
        I := IoResult;
        if I <> 0 then begin
          FreeMem(EP, Len);
          EP := nil;
        end;
        ReadOneExtraField := I;
      end;
    end;
  end;

  function ReadCentralDirHead(var CDH     : CentralDirHead;
                              var FName   : PathStr;
                              var CP      : CommentPtr;
                              var EP      : ExtraPtr) : Word;
    {-Read a central directory header}
  var
    I : Word;
  begin
    CP := nil;
    BlockRead(ZipF, CDH, SizeOf(CDH));
    I := IoResult;
    if I = 0 then
      I := ReadString(CDH.NameLength, FName, SizeOf(PathStr)-1);
    if (I = 0) then
      if arOptionsAreOn(arReadExtraField) then
        I := ReadOneExtraField(EP, CDH.ExtraLength)
      else
        I := SkipZipData(CDH.ExtraLength);
    if (I = 0) and (CDH.CommentLength <> 0) then
      if not arOptionsAreOn(arReadFileComments) then
        I := SkipZipData(CDH.CommentLength)
      else
        I := ReadOneComment(CP, CDH.CommentLength);
    ReadCentralDirHead := I;
  end;

  function ReadCentralDirTail(var CDT : CentralDirTail; var CP : CommentPtr) : Word;
    {-Read the "header" that marks the end of the central directory}
  var
    I : Word;
  begin
    CP := nil;
    BlockRead(ZipF, CDT, SizeOf(CDT));
    I := IoResult;
    if (I = 0) and (CDT.CommentLength <> 0) then
      {Read the archive comment so, if needed, we can write it out}
      I := ReadOneComment(CP, CDT.CommentLength);
    ReadCentralDirTail := I;
  end;

  function FindCentralDir(var CDT : CentralDirTail) : Word;
    {-Move file pointer to beginning of central directory}
  begin
    Seek(ZipF, CDT.CentralDirOfs);
    FindCentralDir := IoResult;
  end;

  procedure FindCentralDirTail;
    {-Move file pointer to tail of central directory}
  label
    AlreadyKnown;
  const
    IdSize    = 4;                {SizeOf(LongInt)}
    BufSize   = 64 {512};
    BufLessId = 60 {508};         {BufSize-IdSize}
  var
    ID, FS, P : LongInt;
    BytesRead, BufPos : Word;
    Buf : array[1..BufSize] of Byte;
  begin
    if TailPos <> -1 then
      goto AlreadyKnown;

    {figure out where to start searching}
    FS := FileSize(ZipF);
    if FS <= BufSize {512} then
      P := 0
    else
      P := FS-BufSize {512};

    {seek to starting point for search}
    Seek(ZipF, P);
    ArchiveStatus := IoResult;
    if ArchiveStatus <> 0 then
      Exit;

    {fill the buffer}
    BlockRead(ZipF, Buf, BufSize, BytesRead);
    ArchiveStatus := IoResult;
    if ArchiveStatus <> 0 then
      Exit;

    {search the buffer for the ID}
    Id := CentralDirTailSig;
    BufPos := Search(Buf, BytesRead, ID, IdSize);

    {loop until Id found or beginning of file reached}
    while (BufPos = $FFFF) and (P > 0) do begin
      {move the front end of the buffer to the tail of the buffer}
      Move(Buf, Buf[BufLessId+1], IdSize);

      {back up the file pointer}
      Dec(P, BufLessId);
      if P < 0 then
        P := 0;
      Seek(ZipF, P);
      ArchiveStatus := IoResult;
      if ArchiveStatus <> 0 then
        Exit;

      {fill the front part of the buffer}
      BlockRead(ZipF, Buf, BufLessId, BytesRead);
      ArchiveStatus := IoResult;
      if ArchiveStatus <> 0 then
        Exit;

      if BytesRead < BufLessId then
        {move things forward if necessary}
        Move(Buf[BufLessId+1], Buf[BytesRead+1], IdSize);

      if BytesRead > 0 then begin
        {adjust BytesRead to indicate the actual number of bytes in the buffer}
        Inc(BytesRead, IdSize);
        {search the buffer for Id}
        BufPos := Search(Buf, BytesRead, ID, IdSize);
      end;
    end;

    if BufPos = $FFFF then begin
      ArchiveStatus := epFatal+ecNotAZipFile;
      Exit;
    end
    else
      TailPos := P+BufPos+IdSize;

AlreadyKnown:
    {position file pointer just beyond the ID}
    Seek(ZipF, TailPos);
    ArchiveStatus := IoResult;
  end;

  procedure InitZipFile(ZipName : PathStr);
    {-Open the ZIP file}
  var                                                                  {!!.02}
    SaveMode : Byte;                                                   {!!.02}
  begin
    SaveMode := FileMode;                                              {!!.02}
    FileMode := $40;                                                   {!!.02}
    Assign(ZipF, ZipName);
    Reset(ZipF, 1);
    FileMode := SaveMode;                                              {!!.02}
    ArchiveStatus := IoResult;
    if ArchiveStatus <> 0 then
      Exit;

    {check for valid file}
    TailPos := -1;
    FindCentralDirTail;
    if ArchiveStatus <> 0 then
      DoneZipFile;

    SaveName := ZipName;
    arOptionsOff(arReadExtraField);
    NewFilePending := False;
    Freshening := False;

    CompressMode := cmBestMethod;    {Default to best method}
    MaxStringMatch := 4;             {Default to fast implode}
    MaxChainLength := 4;             {Default to fast implode}
    DeflateLevel := 5;               {Default to medium speed}         {!!.01}
  end;

  procedure CreateZipFile(ZipName : PathStr);
    {-Create a new ZIP file}
  begin
    ZipName := DefaultExtension(ZipName, 'ZIP');
    Assign(ZipF, ZipName);
    Reset(ZipF, 1);
    if IOResult = 0 then begin
      {Error if file already exists}
      Close(ZipF);
      if IOResult <> 0 then ;
      ArchiveStatus := ecCannotCreate;
      Exit;
    end;

    {Create an empty file}
    Rewrite(ZipF, 1);
    ArchiveStatus := IOResult;
    NewFilePending := True;
    Freshening := False;
    SaveName := ZipName;

    CompressMode := cmBestMethod;    {Deafult to best method}
    MaxStringMatch := 4;             {Default to fast implode}
    MaxChainLength := 4;             {Default to fast implode}
    DeflateLevel := 5;               {Defalut to medium speed}         {!!.01}
  end;

  procedure DoneZipFile;
    {-Close the ZIP file}
  begin
    if FileRec(ZipF).Mode = fmInOut then begin
          Close(ZipF);
      if IoResult <> 0 then {};
    end;
  end;

  procedure Crc32Table; assembler;
  {&FRAME-} {&USES None}
  asm
    DD      000000000h, 077073096h, 0EE0E612Ch, 0990951BAh
    DD      0076DC419h, 0706AF48Fh, 0E963A535h, 09E6495A3h
    DD      00EDB8832h, 079DCB8A4h, 0E0D5E91Eh, 097D2D988h
    DD      009B64C2Bh, 07EB17CBDh, 0E7B82D07h, 090BF1D91h
    DD      01DB71064h, 06AB020F2h, 0F3B97148h, 084BE41DEh
    DD      01ADAD47Dh, 06DDDE4EBh, 0F4D4B551h, 083D385C7h
    DD      0136C9856h, 0646BA8C0h, 0FD62F97Ah, 08A65C9ECh
    DD      014015C4Fh, 063066CD9h, 0FA0F3D63h, 08D080DF5h
    DD      03B6E20C8h, 04C69105Eh, 0D56041E4h, 0A2677172h
    DD      03C03E4D1h, 04B04D447h, 0D20D85FDh, 0A50AB56Bh
    DD      035B5A8FAh, 042B2986Ch, 0DBBBC9D6h, 0ACBCF940h
    DD      032D86CE3h, 045DF5C75h, 0DCD60DCFh, 0ABD13D59h
    DD      026D930ACh, 051DE003Ah, 0C8D75180h, 0BFD06116h
    DD      021B4F4B5h, 056B3C423h, 0CFBA9599h, 0B8BDA50Fh
    DD      02802B89Eh, 05F058808h, 0C60CD9B2h, 0B10BE924h
    DD      02F6F7C87h, 058684C11h, 0C1611DABh, 0B6662D3Dh
    DD      076DC4190h, 001DB7106h, 098D220BCh, 0EFD5102Ah
    DD      071B18589h, 006B6B51Fh, 09FBFE4A5h, 0E8B8D433h
    DD      07807C9A2h, 00F00F934h, 09609A88Eh, 0E10E9818h
    DD      07F6A0DBBh, 0086D3D2Dh, 091646C97h, 0E6635C01h
    DD      06B6B51F4h, 01C6C6162h, 0856530D8h, 0F262004Eh
    DD      06C0695EDh, 01B01A57Bh, 08208F4C1h, 0F50FC457h
    DD      065B0D9C6h, 012B7E950h, 08BBEB8EAh, 0FCB9887Ch
    DD      062DD1DDFh, 015DA2D49h, 08CD37CF3h, 0FBD44C65h
    DD      04DB26158h, 03AB551CEh, 0A3BC0074h, 0D4BB30E2h
    DD      04ADFA541h, 03DD895D7h, 0A4D1C46Dh, 0D3D6F4FBh
    DD      04369E96Ah, 0346ED9FCh, 0AD678846h, 0DA60B8D0h
    DD      044042D73h, 033031DE5h, 0AA0A4C5Fh, 0DD0D7CC9h
    DD      05005713Ch, 0270241AAh, 0BE0B1010h, 0C90C2086h
    DD      05768B525h, 0206F85B3h, 0B966D409h, 0CE61E49Fh
    DD      05EDEF90Eh, 029D9C998h, 0B0D09822h, 0C7D7A8B4h
    DD      059B33D17h, 02EB40D81h, 0B7BD5C3Bh, 0C0BA6CADh
    DD      0EDB88320h, 09ABFB3B6h, 003B6E20Ch, 074B1D29Ah
    DD      0EAD54739h, 09DD277AFh, 004DB2615h, 073DC1683h
    DD      0E3630B12h, 094643B84h, 00D6D6A3Eh, 07A6A5AA8h
    DD      0E40ECF0Bh, 09309FF9Dh, 00A00AE27h, 07D079EB1h
    DD      0F00F9344h, 08708A3D2h, 01E01F268h, 06906C2FEh
    DD      0F762575Dh, 0806567CBh, 0196C3671h, 06E6B06E7h
    DD      0FED41B76h, 089D32BE0h, 010DA7A5Ah, 067DD4ACCh
    DD      0F9B9DF6Fh, 08EBEEFF9h, 017B7BE43h, 060B08ED5h
    DD      0D6D6A3E8h, 0A1D1937Eh, 038D8C2C4h, 04FDFF252h
    DD      0D1BB67F1h, 0A6BC5767h, 03FB506DDh, 048B2364Bh
    DD      0D80D2BDAh, 0AF0A1B4Ch, 036034AF6h, 041047A60h
    DD      0DF60EFC3h, 0A867DF55h, 0316E8EEFh, 04669BE79h
    DD      0CB61B38Ch, 0BC66831Ah, 0256FD2A0h, 05268E236h
    DD      0CC0C7795h, 0BB0B4703h, 0220216B9h, 05505262Fh
    DD      0C5BA3BBEh, 0B2BD0B28h, 02BB45A92h, 05CB36A04h
    DD      0C2D7FFA7h, 0B5D0CF31h, 02CD99E8Bh, 05BDEAE1Dh
    DD      09B64C2B0h, 0EC63F226h, 0756AA39Ch, 0026D930Ah
    DD      09C0906A9h, 0EB0E363Fh, 072076785h, 005005713h
    DD      095BF4A82h, 0E2B87A14h, 07BB12BAEh, 00CB61B38h
    DD      092D28E9Bh, 0E5D5BE0Dh, 07CDCEFB7h, 00BDBDF21h
    DD      086D3D2D4h, 0F1D4E242h, 068DDB3F8h, 01FDA836Eh
    DD      081BE16CDh, 0F6B9265Bh, 06FB077E1h, 018B74777h
    DD      088085AE6h, 0FF0F6A70h, 066063BCAh, 011010B5Ch
    DD      08F659EFFh, 0F862AE69h, 0616BFFD3h, 0166CCF45h
    DD      0A00AE278h, 0D70DD2EEh, 04E048354h, 03903B3C2h
    DD      0A7672661h, 0D06016F7h, 04969474Dh, 03E6E77DBh
    DD      0AED16A4Ah, 0D9D65ADCh, 040DF0B66h, 037D83BF0h
    DD      0A9BCAE53h, 0DEBB9EC5h, 047B2CF7Fh, 030B5FFE9h
    DD      0BDBDF21Ch, 0CABAC28Ah, 053B39330h, 024B4A3A6h
    DD      0BAD03605h, 0CDD70693h, 054DE5729h, 023D967BFh
    DD      0B3667A2Eh, 0C4614AB8h, 05D681B02h, 02A6F2B94h
    DD      0B40BBE37h, 0C30C8EA1h, 05A05DF1Bh, 02D02EF8Dh
  end;

  procedure UpdateCRC(var CRC : LongInt; var Buffer; Len : {$IFDEF VirtualPascal} SmallWord {$ELSE} Word {$ENDIF}); far;
    {-Update 32-bit CRC based on first Len bytes in Buffer}
  begin
    asm
{$IFDEF VIRTUALPASCAL}
      MOVzx   ECX,Len                 {CX = Len}
      JECXZ   @@ucDone                {nothing to do if Len = 0}

      PUSH    ESI
      PUSH    EDI
      PUSH    EBX
      MOV     EDI,CRC                 {EDI => CRC}
      MOV     EAX,[EDI]               {EAX = CRC}
      MOV     ESI,Buffer              {ESI => Buffer}
      CLD                             {go forward}

  @@ucNext:
      MOV     BL,AL                   {BL = AL}
      LODSB                           {load next byte into AL}
      XOR     BL,AL                   {XOR BL with AL}
      MOVZX   EBX,BL                  {use result as index into DWORD table}
      SHL     EBX,2
      SHR     EAX,8                   {shift EAX right 8 bits}
      XOR     EAX,[OFFSET Crc32Table+EBX]    {XOR with CRC table entry}
      LOOP    @@ucNext                {repeat}

      MOV     EDI,CRC                 {ES:DI => CRC}
      STOSD                           {store dword}
      POP     EBX
      POP     EDI
      POP     ESI
{$ELSE}
      MOV     CX,Len                  {CX = Len}
      JCXZ    @@ucDone                {nothing to do if Len = 0}

      PUSH    DS                      {save DS}
      LDS     DI,CRC                  {DS:DI => CRC}
      MOV     AX,DS:[DI]
      MOV     DX,DS:[DI+2]            {DX:AX = CRC}
      LDS     SI,Buffer               {DS:SI => Buffer}
      CLD                             {go forward}
  @@ucNext:
      MOV     BL,AL                   {BL = AL}
      LODSB                           {load next byte into AL}
      XOR     BL,AL                   {XOR BL with AL}
      XOR     BH,BH                   {use result as index into DWORD table}
      SHL     BX,1
      SHL     BX,1
      MOV     AL,AH                   {shift DX:AX !RIGHT! 8 bits}
      MOV     AH,DL
      MOV     DL,DH
      XOR     DH,DH
      ADD     BX,OFFSET Crc32Table
      XOR     AX,CS:[BX]              {XOR with CRC table entry}
      XOR     DX,CS:[BX+2]
      LOOP    @@ucNext                {repeat}

      LES     DI,CRC                  {ES:DI => CRC}
      STOSW                           {store low word}
      MOV     AX,DX                   {store high word}
      STOSW
      POP     DS                      {restore DS}
{$ENDIF}
  @@ucDone:
    end;
  end;

{------------ file decompression -----------}

type
  Follower =                      {used to expand reduced files}
    record
      Size : Byte;                {size of follower set}
      FSet : array[0..31] of Byte; {follower set}
    end;
  FollowerSets = array[0..255] of Follower;

  SfEntryPtr = ^SfEntry;
  SfEntry =                       {entry in a Shannon-Fano tree}
    record
      case Byte of
        0 : (Code : {$IFDEF VirtualPascal} SmallWord {$ELSE} Word {$ENDIF}; Value, BitLength : Byte);
        1 : (L : LongInt);
    end;
  SfTree =
    record                        {a Shannon-Fano tree}
      Entries : {$IFDEF VirtualPascal} SmallInt {$ELSE} Integer {$ENDIF};
      MaxLength : {$IFDEF VirtualPascal} SmallInt {$ELSE} Integer {$ENDIF};
      Entry : array[0..256] of SfEntry;
    end;

  ByteArray4K = array[1..4096] of Byte;
  ByteArray8K = array[0..8192] of Byte;
  IntArray8K  = array[0..8192] of {$IFDEF VirtualPascal} SmallInt {$ELSE} Integer {$ENDIF};

var
  gCDH : CentralDirHead;          {a central directory header}

  InBuf : ^ByteArray4K;           {input buffer}
  InPos : Integer;                {current position in input buffer}
  InCnt : Integer;                {number of bytes in input buffer}
  InLeft : LongInt;               {bytes remaining in compressed input file}
  InEof  : Boolean;               {set when InLeft = 0}

  CurByte : Byte;                 {current input byte}
  BitsLeft : Byte;                {bits left to process in CurByte}

  OutBuf : ^ByteArray8K;          {output buffer}
  OutSent : LongInt;              {number of bytes sent to output buffer}
  OutPos : Integer;               {current position in output buffer}

  OutF : File;                    {output file}

  Factor : Byte;                  {reduction factor}
  FactorMask : Byte;              {bit mask to use based on Factor}
  Followers : ^FollowerSets;      {array of follower sets}
  State : Integer;                {used while processing reduced files}
  C : Byte;                       {"}
  V : Integer;                    {"}
  Len : Integer;                  {"}

  PrefixTable : ^IntArray8K ;     {used while processing shrunk files}
  SuffixTable : ^ByteArray8K;     {"}
  Stack : ^ByteArray8K;           {"}
  StackIndex : Integer;           {"}
  HeadTable : ^IntArray8K;        {used while shrinking files}

  LitTree : ^SfTree;              {Literal tree}
  LengthTree : ^SfTree;           {Length tree}
  DistanceTree : ^SfTree;         {Distance tree}
  MinMatchLength : Integer;       {minimum match length}
  DictBits : Integer;             {number of bits used in sliding dictionary}


  procedure ReadNext;
    {-Read next byte from input stream}
  var
    L : LongInt;
  begin
    {do we still have a byte buffered?}
    if InPos <= InCnt then begin
      {get next byte out of buffer and advance position counter}
      CurByte := InBuf^[InPos];
      Inc(InPos);
    end
    {are there any left to read?}
    else if (InLeft = 0) then begin
      {we're done}
      InEof := True;
      InPos := InCnt+1;
    end
    else begin
      {refresh the buffer}
      if InLeft > SizeOf(InBuf^) then
        L := SizeOf(InBuf^)
      else
        L := InLeft;
      BlockRead(ZipF, InBuf^, L, InCnt);
      ArchiveStatus := IoResult;
      InEof := (ArchiveStatus <> 0);

      {decrement count of bytes left to go}
      Dec(InLeft, InCnt);

      {load first byte in buffer and set position counter}
      CurByte := InBuf^[1];
      InPos := 2;
    end;
  end;

  function ReadBits(Bits : Byte) : Integer;
    {-Read the specified number of bits}
  var
    SaveCurByte, Delta, SaveBitsLeft, Tmp : Byte; Tmp1 : LongInt;
  begin
    {read next byte if we're out of bits}
    if BitsLeft = 0 then begin
      ReadNext;
      BitsLeft := 8;
    end;

    if (Bits < BitsLeft) then begin
      {$IFDEF VirtualPascal}
      asm
        push   ebx
        mov    cl,Bits
        sub    bitsleft,cl
        movzx  eax,curByte
        mov    ebx,1
        shl    ebx,cl
        dec    ebx
        and    ebx,eax
        shr    eax,cl
        mov    CurByte,al
        mov    eax,ebx         {function result in eax}
        pop    ebx
        mov    Tmp1,eax
      end;
      ReadBits := Tmp1;
      {$ELSE}
      inline(
        $8A/$4E/<Bits/         {mov cl,[bp+<Bits]     ;cl = Bits}
        $28/$0E/>BitsLeft/     {sub [>BitsLeft],cl    ;Dec(BitsLeft, Bits)}
        $A0/>CurByte/          {mov al,[>CurByte]     ;ax = CurByte}
        $30/$E4/               {xor ah,ah}
        $BB/$01/$00/           {mov bx,1              ;bx = 1 shl Bits -1}
        $D3/$E3/               {shl bx,cl}
        $4B/                   {dec bx}
        $21/$C3/               {and bx,ax             ;ReadBits = bx and CurByte}
        $89/$5E/<ReadBits/     {mov [bp+<ReadBits],bx}
        $D3/$E8/               {shr ax,cl             ;CurByte = CurByte shr Bits}
        $A2/>CurByte);         {mov [>CurByte],al}
      {$ENDIF}
    end
    else if (Bits = BitsLeft) then begin
      {return what we have}
      {$IFDEF VirtualPascal}
      {$ALTERS eax}
      asm
        xor    eax,eax
        xchg   al,[CurByte]
        mov    Tmp,al
        mov    bitsleft,ah
      end;
      ReadBits := Tmp;
      {$ELSE}
      inline(
        $31/$C0/               {xor  ax,ax             ;ax = 0}
        $86/$06/>CurByte/      {xchg al,[>CurByte]     ;al = CurByte, CurByte = 0}
        $89/$46/<ReadBits/     {mov  [bp+<ReadBits],ax ;ReadBits = CurByte}
        $88/$26/>BitsLeft);    {mov  [>BitsLeft],ah    ;BitsLeft = 0}
      {$ENDIF}
    end
    else begin
      {save what we have}
      SaveCurByte := CurByte;
      SaveBitsLeft := BitsLeft;

      {number of additional bits that we need}
      Delta := Bits-BitsLeft;

      {read next byte}
      ReadNext;
      BitsLeft := 8;

      {make recursive call to read remaining bits; merge with saved bits}
      ReadBits := (ReadBits(Delta) shl SaveBitsLeft) or SaveCurByte;
    end;
  end;

  procedure FlushOutputBuffer;
    {-Flush contents of output buffer}
  begin
    UpdateCRC(Crc, OutBuf^, OutPos);
    BlockWrite(OutF, OutBuf^, OutPos);
    ArchiveStatus := IoResult;
    OutPos := 0;
    if ArchiveStatus = 0 then
      if @glSPF <> nil then
        if not glSPF(OutSent, gCDH.OrigSize) then
          ArchiveStatus := epFatal+ecUserAbort;
    if ArchiveStatus <> 0 then
      InLeft := 0;
  end;

  procedure WriteByte(B : Byte);
    {-Write one byte to the output stream}
  begin
    OutBuf^[OutPos] := B;
    Inc(OutSent);
    Inc(OutPos);
    if OutPos = SizeOf(OutBuf^) then
      FlushOutputBuffer;
  end;

  {--------- Stored files ----------}

  procedure UnStore;
    {-Extract a stored file}
  var
    L : LongInt;
  begin
    repeat
      if InLeft > SizeOf(InBuf^) then
        L := SizeOf(InBuf^)
      else
        L := InLeft;
      BlockRead(ZipF, InBuf^, L, InCnt);
      ArchiveStatus := IoResult;
      if ArchiveStatus = 0 then begin
        UpdateCRC(Crc, InBuf^, InCnt);
        BlockWrite(OutF, InBuf^, InCnt);
        Inc(OutSent, InCnt);
        Dec(InLeft, InCnt);
        ArchiveStatus := IoResult;
        if (ArchiveStatus = 0) and (@glSPF <> nil) then
          if not glSPF(OutSent, gCDH.OrigSize) then
            ArchiveStatus := epFatal+ecUserAbort;
      end;
    until (InLeft = 0) or (ArchiveStatus <> 0);
    OutPos := 0;
  end;

{---- Reduced files ---------------}

  function BitsNeeded(X : Byte) : Word;
    {-Calculate number of bits needed to encode the specified value}
  {$IFDEF VirtualPascal}
  assembler; {$USES none} {$FRAME-} {$ALTERS edx,ecx}
  asm
    movzx  edx,x
    dec    edx
    xor    eax,eax
    mov    ecx,8
  @@x1:
    inc    eax
    shr    bl,1
    loopnz @@x1
  end;
  {$ELSE}
  inline(
    $5B/                   {pop bx      ;BL = X-1}
    $4B/                   {dec bx}
    $31/$C0/               {xor ax,ax   ;AX = 0}
    $B9/$08/$00/           {mov cx,8    ;repeat at most 7 times}
                           {x1:}
    $40/                   {inc ax      ;increment bit count}
    $D0/$EB/               {shr bl,1    ;shift left most bit into CF}
    $E0/$FB);              {loopnz x1   ;repeat if <> 0}
  {$ENDIF}

  procedure UnReduce;
    {-Extract a file that was reduced}
  label
    ExitPoint;
  const
    FactorMasks : array[1..4] of Byte = ($7F, $3F, $1F, $0F);
    DLE = 144;
  var
    Last : Byte;
    OpI : LongInt;
    OpO : LongInt;
    I, J, Sz : Integer;
    D : Word;
  begin
    if not GetMemCheck(Followers, SizeOf(Followers^)) then begin
      ArchiveStatus := epFatal+ecOutOfMemory;
      Exit;
    end;

    Factor := gCDH.Method-1;
    FactorMask := FactorMasks[Factor];
    State := 0;
    C := 0;

    {load follower sets}
    for I := 255 downto 0 do begin
      Sz := ReadBits(6);
      Followers^[I].Size := Sz;
      Dec(Sz);
      for J := 0 to Sz do
        Followers^[I].FSet[J] := ReadBits(8);
    end;

    while (not InEof) and (OutSent < gCDH.OrigSize) do begin
      Last := C;
      with Followers^[Last] do
        if Size = 0 then
          C := ReadBits(8)
        else begin
          C := ReadBits(1);
          if C <> 0 then
            C := ReadBits(8)
          else
            C := FSet[ReadBits(BitsNeeded(Size))];
        end;

      if InEof then
        goto ExitPoint;

      case State of
        0 :
          if C <> DLE then
            WriteByte(C)
          else
            State := 1;
        1 :
          if C <> 0 then begin
            V := C;
            Len := V and FactorMask;
            if Len = FactorMask then
              State := 2
            else
              State := 3;
          end
          else begin
            WriteByte(DLE);
            State := 0;
          end;

        2 :
          begin
            Inc(Len, C);
            State := 3;
          end;

        3 :
          begin
            case Factor of
              1 : D := (V shr 7) and $01;
              2 : D := (V shr 6) and $03;
              3 : D := (V shr 5) and $07;
              4 : D := (V shr 4) and $0f;
            end;
            OpI := OutSent-(Swap(D)+C+1);

            if OpI >= SizeOf(OutBuf^) then
              OpO := OpI mod SizeOf(OutBuf^)
            else
              OpO := OpI;
            for I := 0 to Len+2 do begin
              if OpI < 0 then
                WriteByte(0)
              else
                WriteByte(OutBuf^[OpO]);
              Inc(OpI);
              Inc(OpO);
              if OpO >= SizeOf(OutBuf^) then
                OpO := 0;
            end;

            State := 0;
          end;
      end;
    end;

ExitPoint:
    FreeMemCheck(Followers, SizeOf(Followers^));
  end;

{------- Shrunk files ------------}

  procedure ClearHighBit(var I : {$IFDEF VirtualPascal} SmallInt {$ELSE} Integer {$ENDIF});
    {-Clear the high bit of I}
  {$IFDEF VirtualPascal}
  assembler; {$FRAME-} {$Uses None} {$ALTERS eax}
  asm
    mov   eax,i
    and   word ptr [eax],$7fff
  end;
  {$ELSE}
  inline(
    $5F/                   {pop di       ;ES:DI => I}
    $07/                   {pop es}
    $26/$81/$25/$FF/$7F);  {and word ptr es:[di],$7FFF}
  {$ENDIF}

  procedure SetHighBits(var FirstNode; Count : Word);
    {-Set the high bit of I}
  {$IFDEF VirtualPascal}
  assembler; {$FRAME-} {$Uses edi} {$ALTERS ecx}
  asm
    mov     ecx,Count
    mov     edi,FirstNode
    jecxz   @@done
    clc
  @@again:
    or      word ptr [edi],$8000
    inc     edi
    inc     edi
    loop    @@again
  @@done:
  end;
  {$ELSE}
  inline(
    $59/                   {pop cx       ;CX = Count}
    $5F/                   {pop di       ;ES:DI => I}
    $07/                   {pop es}
    {F8/}                  {clc          ;go forward}
    $E3/$09/               {jcxz done}
                           {again:}
    $26/$81/$0D/$00/$80/   {or word ptr es:[di],$8000}
    $47/                   {inc di}
    $47/                   {inc di}
    $E2/$F7);              {loop again}
                           {done:}
  {$ENDIF}

  procedure ClearMarkedNodes(var FirstNode; Count : Word);
    {-Set all unmarked nodes to -1}
  {$IFDEF VirtualPascal}
  assembler; {$FRAME-} {$USES edi}
  asm
    mov     ecx,Count
    mov     edi,FirstNode
    clc
    jecxz   @@done
  @@again:
    movzx   eax,word ptr [edi]
    test    eax,$8000
    jz      @@nope
    mov     eax,-1
  @@nope:
    stosw
    loop    @@again
  @@done:
  end;
  {$ELSE}
  inline(
    $59/                   {pop cx       ;CX = Count}
    $5F/                   {pop di       ;ES:DI => FirstNode}
    $07/                   {pop es}
    $FC/                   {clc          ;go forward}
    $E3/$0E/               {jcxz done}
                           {again:}
    $26/$8B/$05/           {mov ax,es:[di]}
    $A9/$00/$80/           {test ax,$8000}
    $74/$03/               {jz nope}
    $B8/$FF/$FF/           {mov ax,$FFFF}
                           {nope:}
    $AB/                   {stosw}
    $E2/$F2);              {loop again}
                           {done:}
  {$ENDIF}

  procedure UnShrink;
    {-Extract a file that was shrunk}
  label
    ExitPoint;
  const
    MaxBits = 13;
    InitBits = 9;
    FirstFree = 257;
    Clear = 256;
    MaxCodeMax = 8192; {= 1 shl MaxBits}
  var
    CodeSize : Integer;
    MaxCode : Integer;
    BaseChar : Integer;
    NewCode : Integer;
    OldCode : Integer;
    SaveCode : Integer;
    N, R : Integer;
  begin
    CodeSize := InitBits;
    MaxCode := (1 shl InitBits)-1;
    NextFree := FirstFree;

    SuffixTable := nil;
    Stack := nil;

    if not (
      GetMemCheck(PrefixTable, SizeOf(PrefixTable^)) and
      GetMemCheck(SuffixTable, SizeOf(SuffixTable^)) and
      GetMemCheck(Stack, SizeOf(Stack^)) ) then begin
        ArchiveStatus := epFatal+ecOutOfMemory;
        goto ExitPoint;
    end;

    FillChar(PrefixTable^, SizeOf(PrefixTable^), $FF);
    for NewCode := 255 downto 0 do begin
      PrefixTable^[NewCode] := 0;
      SuffixTable^[NewCode] := NewCode;
    end;

    OldCode := ReadBits(CodeSize);
    if InEof then
      goto ExitPoint;
    BaseChar := OldCode;

    WriteByte(BaseChar);

    StackIndex := 0;
    while (not InEof) do begin
      NewCode := ReadBits(CodeSize);
      while (NewCode = Clear) and (not InEof) do begin
        case ReadBits(CodeSize) of
          1 : begin
                Inc(CodeSize);
                if CodeSize = MaxBits then
                  MaxCode := MaxCodeMax
                else
                  MaxCode := (1 shl CodeSize)-1;
              end;
          2 : begin
                {mark all nodes as potentially unused}
                SetHighBits(PrefixTable^[FirstFree], NextFree-FirstFree);

                {unmark those used by other nodes}
                for N := FirstFree to NextFree-1 do begin
                  {reference to another node?}
                  R := PrefixTable^[N] and $7FFF;
                  {flag node as referenced}
                  if R >= FirstFree then
                    ClearHighBit(PrefixTable^[R]);
                end;

                {clear the ones that are still marked}
                ClearMarkedNodes(PrefixTable^[FirstFree], NextFree-FirstFree);

                {recalculate NextFree}
                NextFree := FirstFree;

                while (NextFree < MaxCodeMax) and (PrefixTable^[NextFree] <> -1) do
                  Inc(NextFree);
              end;
        end;

        NewCode := ReadBits(CodeSize);
      end;

      if InEof then
        goto ExitPoint;

      {save current code}
      SaveCode := NewCode;

      {special case}
      if PrefixTable^[NewCode] = Unused then begin
        Stack^[StackIndex] := BaseChar;
        Inc(StackIndex);
        NewCode := OldCode;
      end;

      {generate output characters in reverse order}
      while (NewCode >= FirstFree) do begin
        if Prefixtable^[NewCode] = Unused then begin
          Stack^[StackIndex] := BaseChar;
          Inc(StackIndex);
          NewCode := OldCode;
        end else begin
          Stack^[StackIndex] := SuffixTable^[NewCode];
          Inc(StackIndex);
          NewCode := PrefixTable^[NewCode];
        end;
      end;

      BaseChar := SuffixTable^[NewCode];
      WriteByte(BaseChar);

      {put them out in forward order}
      while (StackIndex > 0) do begin
        Dec(StackIndex);
        WriteByte(Stack^[StackIndex]);
      end;

      {add new entry to tables}
      NewCode := NextFree;
      if NewCode < MaxCodeMax then begin
        PrefixTable^[NewCode] := OldCode;
        SuffixTable^[NewCode] := BaseChar;
        while (NextFree < MaxCodeMax) and (PrefixTable^[NextFree] <> Unused) do
          Inc(NextFree);
      end;

      {remember previous code}
      OldCode := SaveCode;
    end;

ExitPoint:
    FreeMemCheck(PrefixTable, SizeOf(PrefixTable^));
    FreeMemCheck(SuffixTable, SizeOf(SuffixTable^));
    FreeMemCheck(Stack, SizeOf(Stack^));
  end;

{---- Imploded files ---------}

  procedure ReverseBits(var W : {$IFDEF VirtualPascal} SmallWord {$ELSE} Word {$ENDIF});
    {-Reverse the order of the bits in W}
  {$IFDEF VirtualPascal}
  assembler; {$FRAME-} {$USES edi}
  asm
    mov    edi,w
    mov    bx,word ptr [edi]
    xor    eax,eax
    mov    ecx,16
  @@x1:
    shr    bx,1
    rcl    ax,1
    loop   @@x1
    stosw
  end;
  {$ELSE}
  Inline(
    $5F/                   {pop di       ;ES:DI => W}
    $07/                   {pop es}
    $26/                   {es:}
    $8B/$1D/               {mov bx,[di]  ;BX = W}
    $31/$C0/               {xor ax,ax    ;AX = 0}
    $B9/$10/$00/           {mov cx,16    ;repeat 16 times}
                           {x1:}
    $D1/$EB/               {shr bx,1     ;shift rightmost bit into CF}
    $D1/$D0/               {rcl ax,1     ;rotate CF into AX}
    $E2/$FA/               {loop x1      ;repeat}
    $AB);                  {stosw        ;W = AX}
  {$ENDIF}

  procedure SortLengths(var Tree : SfTree);
    {-Sort the Bit Lengths in ascending order, while retaining the order
      of the original lengths stored in the file}
  const
    XL : Integer = 0;
    XGL : Integer = 0;
    TXP  : SfEntryPtr = nil;
    TXGP : SfEntryPtr = nil;
  var
    X, Gap : Integer;
    Done : Boolean;
    LT : LongInt;
  begin
    Gap := Tree.Entries shr 1;
    repeat
      repeat
        Done := True;
        for X := 0 to (Tree.Entries-1)-Gap do begin
          TXP := @Tree.Entry[X];
          TXGP := @Tree.Entry[X+Gap];
          XL := TXP^.BitLength;
          XGL := TXGP^.BitLength;
          if (XL > XGL) or ((XL = XGL) and (TXP^.Value > TXGP^.Value)) then begin
            LT := TXP^.L;
            TXP^.L := TXGP^.L;
            TXGP^.L := LT;
            Done := False;
          end;
        end;
      until Done;

      Gap := Gap shr 1;
    until (Gap = 0);
  end;

  procedure ReadLengths(var Tree : SfTree);
    {-Read bit lengths for a tree}
  var
    TreeBytes : Integer;
    I, J, K : Integer;
    Num, Len : Integer;
    B : Byte;
  begin
    {get number of bytes in compressed tree}
    TreeBytes := ReadBits(8)+1;

    I := 0;
    Tree.MaxLength := 0;

    {High nibble: Number of values at this bit length + 1.
     Low  nibble: Bits needed to represent value + 1}
    for J := 1 to TreeBytes do begin
      if j = 196 then
      write;
      B := ReadBits(8);
      Len := (B and $0F)+1;
      Num := (B shr 4)+1;

      for K := I to I+Num-1 do
        with Tree, Entry[K] do begin
          if Len > MaxLength then
            MaxLength := Len;
          BitLength := Len;
          Value := K;
        end;
      Inc(I, Num);

      Dec(TreeBytes);
    end;
  end;

  procedure GenerateTree(var Tree : SfTree);
    {-Generate a Shannon-Fano tree}
  var
    C : Word;
    CodeIncrement : Integer;
    LastBitLength : Integer;
    I : Integer;
  begin
    C := 0;
    CodeIncrement := 0;
    LastBitLength := 0;

    for I := Tree.Entries-1 downto 0 do
      with Tree.Entry[I] do begin
        Inc(C, CodeIncrement);
        if BitLength <> LastBitLength then begin
          LastBitLength := BitLength;
          CodeIncrement := 1 shl (16-LastBitLength);
        end;
        Code := C;
      end;
  end;

  procedure LoadTree(var Tree : SfTree; TreeSize : Integer);
    {-Load one Shannon-Fano tree}
  var
    I : Word;
  begin
    Tree.Entries := TreeSize;
    ReadLengths(Tree);
    SortLengths(Tree);
    GenerateTree(Tree);
    for I := 0 to TreeSize-1 do
      ReverseBits(Tree.Entry[I].Code);
  end;

  function ReadTree(var Tree : SfTree) : Byte;
    {-Read next byte using a Shannon-Fano tree}
  const
    Bits : Integer = 0;
    CV   : Word = 0;
    E    : Integer = 0;
    Cur  : Integer = 0;
  begin
    ReadTree := 0;
    Bits := 0;
    CV := 0;
    Cur := 0;
    E := Tree.Entries;

    repeat
      CV := CV or (ReadBits(1) shl Bits);
      Inc(Bits);

      while Tree.Entry[Cur].BitLength < Bits do begin
        Inc(Cur);
        if Cur >= E then
          Exit;
      end;

      while Tree.Entry[Cur].BitLength = Bits do begin
        if Tree.Entry[Cur].Code = CV then begin
          ReadTree := Tree.Entry[Cur].Value;
          Exit;
        end;

        Inc(Cur);
        if Cur >= E then
          Exit;
      end;
    until False;
  end;

  procedure UnImplode;
    {-Extract an imploded file}
  label
    ExitPoint;
  const
    Length : Integer = 0;
    DI : Integer = 0;
  var
    DIndex : LongInt;
    Distance : Integer;
  begin
    {do we have an 8K dictionary?}
    if (gCDH.BitFlag and $02) <> 0 then
      DictBits := 7
    else
      DictBits := 6;

    {allocate trees}
    DistanceTree := nil;
    LitTree := nil;
    if not (
      GetMemCheck(LengthTree, SizeOf(LengthTree^)-(192*SizeOf(SfEntry))) and
      GetMemCheck(DistanceTree, SizeOf(DistanceTree^)-(192*SizeOf(SfEntry)))
      ) then begin
        ArchiveStatus := epFatal+ecOutOfMemory;
        goto ExitPoint;
    end;

    {do we have a Literal tree?}
    if (gCDH.BitFlag and $04) <> 0 then begin
      if not GetMemCheck(LitTree, SizeOf(LitTree^)) then begin
        ArchiveStatus := ecOutOfMemory;
        goto ExitPoint;
      end;
      LoadTree(LitTree^, 256);
      MinMatchLength := 3;
    end
    else
      MinMatchLength := 2;

    {load the other two trees}
    LoadTree(LengthTree^, 64);
    LoadTree(DistanceTree^, 64);

    while (not InEof) and (OutSent < gCDH.OrigSize) do
      {is data literal?}
      if Boolean(ReadBits(1)) then begin
        {if MinMatchLength = 3 then we have a Literal tree}
        if (MinMatchLength = 3) then
          WriteByte( ReadTree(LitTree^) )
        else
          WriteByte( ReadBits(8) );
      end
      else begin
        {data is a sliding dictionary}
        Distance := ReadBits(DictBits);

        {using the Distance Shannon-Fano tree, read and decode the
         upper 6 bits of the Distance value}
        Distance := Distance or (ReadTree(DistanceTree^) shl DictBits);

        {using the Length Shannon-Fano tree, read and decode the Length value}
        Length := ReadTree(LengthTree^);
        if Length = 63 then
          Inc(Length, ReadBits(8));
        Inc(Length, MinMatchLength);

        {move backwards Distance+1 bytes in the output stream, and copy
         Length characters from this position to the output stream.
         (if this position is before the start of the output stream,
         then assume that all the data before the start of the output
         stream is filled with zeros)}
        DIndex := OutSent-(Distance+1);
        DI := DIndex mod SizeOf(OutBuf^);
        while Length > 0 do begin
          if DI < 0 then
            WriteByte(0)
          else
            WriteByte(OutBuf^[DI]);
          Inc(DI);
          if DI >= SizeOf(OutBuf^) then
            DI := 0;
          Dec(Length);
        end;
      end;

ExitPoint:
    FreeMemCheck(LitTree, SizeOf(LitTree^));
    FreeMemCheck(LengthTree, SizeOf(LengthTree^)-(192*SizeOf(SfEntry)));
    FreeMemCheck(DistanceTree, SizeOf(DistanceTree^)-(192*SizeOf(SfEntry)));
  end;

  procedure ExtractFileZip(var Header : CentralDirHead; OutName : PathStr);
    {-Extract a single file}
  label
    ExitPoint;
  var
    I : Word;
    FP : LongInt;
    LH : LocalHeader;
    FName : PathStr;
  begin
    {reset internal variables}
    ArchiveStatus := 0;
    gCDH := Header;
    BitsLeft := 0;
    CurByte := 0;
    InCnt := 0;
    InLeft := gCDH.NewSize;
    InPos := 1+SizeOf(InBuf^);
    OutSent := 0;
    OutPos := 0;
    Crc := -1;
    InEof := False;

    {make sure we know the compression method}
    if (Lo(gCDH.VersionNeeded) > MaxUnzipVer) or                       {!!.01}
       (gCDH.Method = cmcTokenized) or                                 {!!.01}
       (gCDH.Method > cmcDeflated) then begin                          {!!.01}
      ArchiveStatus := epNonFatal+ecUnknownMethod;
      Exit;
    end;

    {can't extract encrypted files}
    if gCDH.BitFlag and $0001 <> 0 then begin
      ArchiveStatus := epNonFatal+ecFileEncrypted;
      Exit;
    end;

    {try to allocate I/O buffers}
    InBuf := nil;
    OutBuf := nil;
    if not ( GetMemCheck(OutBuf, SizeOf(OutBuf^)) and
             GetMemCheck(InBuf, SizeOf(InBuf^)) ) then begin
      ArchiveStatus := epFatal+ecOutOfMemory;
      goto ExitPoint;
    end;

    {save current file position}
    FP := FilePos(ZipF);

    {move file pointer to start of compressed data}
    Seek(ZipF, gCDH.LocalHeaderOfs+SizeOf(LongInt));
    ArchiveStatus := ReadLocalHeader(LH, FName);
    if ArchiveStatus <> 0 then
      goto ExitPoint;

    {try to create output file}
    CreateOutputFile(OutF, OutName);
    if ArchiveStatus <> 0 then begin
      case ArchiveStatus of
        ecPathNotFound, ecInvalidDrive, ecDiskFull, ecDriveNotReady : {};
        else ArchiveStatus := epNonFatal+ecCannotCreate;
      end;
      Seek(ZipF, FP);
      I := IoResult;
      goto ExitPoint;
    end;

    {do it}
    case gCDH.Method of
      cmcStored :
        UnStore;
      cmcShrunk :
        UnShrink;
      cmcReduced1..cmcReduced4 :
        UnReduce;
      cmcImploded :
        UnImplode;
      cmcDeflated :                                                    {!!.01}
        InflateFile;                                                   {!!.01}
    end;

    {any bytes left in output buffer?}
    if (OutPos > 0) and (ArchiveStatus = 0) then
      {flush output buffer and update CRC}
      FlushOutputBuffer;

    {set date/time stamp and close the file}
    SetFTime(OutF, MakeLongInt(gCDH.Date, gCDH.Time));
    Close(OutF);
    I := IoResult;
    if ArchiveStatus = 0 then
      ArchiveStatus := I;
    if ArchiveStatus <> 0 then
      Erase(OutF);
    I := IoResult;
    if ArchiveStatus = 0 then
      ArchiveStatus := I;

    {reset file pointer}
    Seek(ZipF, FP);
    I := IoResult;
    if ArchiveStatus = 0 then
      ArchiveStatus := I;

    {check the CRC}
    if ArchiveStatus = 0 then begin
      Crc := not Crc;
      if Crc <> gCDH.Crc then
        ArchiveStatus := epNonFatal+ecBadFileCRC;
    end;

ExitPoint:
    {dispose of buffers}
    FreeMemCheck(OutBuf, SizeOf(OutBuf^));
    FreeMemCheck(InBuf, SizeOf(InBuf^));
  end;

  procedure ExtractFileMaskListZip(var FML : FileMaskList);
    {-Extract all files that match the file mask list}
  var
    ZFL : ZipFileList;
    SaveOptions : Word;
  begin
    {initialize ZFL}
    InitZipFileList(ZFL);

    {build the list of files}
    SaveOptions := DefArchiveOptions;
    ClearFlag(DefArchiveOptions, arReadFileComments);
    BuildZipFileList(ZFL, FML);
    DefArchiveOptions := SaveOptions;
    if ArchiveStatus = 0 then
      {extract the files}
      ExtractZipFileList(ZFL);
    {dispose of ZFL}
    DoneZipFileList(ZFL);
  end;

  procedure ExtractZip(Mask : PathStr);
    {-Extract all files that match Maskt}
  var
    FML : FileMaskList;
  begin
    InitFileMaskList(FML);
    if not AppendFileMask(Mask, FML) then begin
      ArchiveStatus := ecOutOfMemory;
      Exit;
    end;

    ExtractFileMaskListZip(FML);

    DoneFileMaskList(FML);
  end;
